[h2]Tutorial de introducción a Symfony2[/h2]

El objetivo este tutorial es ofrecer una visión panorámica del framework PHP para el desarrollo de aplicaciones web [i]Symfony2[/i]. El desarrollo de una sencilla aplicación aplicación web servirá como elemento vertebrador de este documento.
Para seguir el tutorial necesitarás un entorno con:
[list]
[*] un servidor web con PHP 5.3.x (x>2)
[*] un servidor MySQL 5
[*] tu IDE o editor favorito
[/list]
[h3]Descripción de la aplicación[/h3]
Vamos a construir una aplicación web para elaborar y consultar un repositorio de alimentos con datos acerca de sus propiedades dietéticas. Utilizaremos una base de datos para almacenar dichos datos que consistirá en una sola tabla con la siguiente información sobre alimentos:
[list]
[*] El nombre del alimento,
[*] la energía en kilocalorías ,
[*] la cantidad de proteínas,
[*] la cantidad hidratos de carbono  en gramos
[*] la cantidad de fibra en gramos  y
[*] la cantidad de grasa en gramos,
[/list]
todo ello por cada 100 gramos de alimento.
Aunque se trata de una aplicación muy sencilla,  cuenta con los elementos suficientes para mostrar las características básicas de [i]Symfony2[/i].
Utilizando algún cliente [i]MySQL[/i] ([i]phpMyAdmin[/i], por ejemplo) crea la siguiente base
de datos para almacenar los alimentos e introduce algunos registros para probar la 
aplicación.

 [code]CREATE TABLE `alimentos` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `nombre` varchar(255) NOT NULL,
      `energia` decimal(10,0) NOT NULL,
      `proteina` decimal(10,0) NOT NULL,
      `hidratocarbono` decimal(10,0) NOT NULL,
      `fibra` decimal(10,0) NOT NULL,
      `grasatotal` decimal(10,0) NOT NULL,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;[/code]

¡Y ya podemos comenzar el tutorial!

¿Qué es [i]Symfony2[/i]?

La respuesta rápida, no por ello menos cierta, es que [i]Symfony2[/i] es un framework
[i]PHP[/i] para  el desarrollo  de aplicaciones  web. Sin  embargo, los  creadores de
[i]Symfony2[/i] no la darían por  buena. Posiblemente tampoco aprobasen completamente
lo  que  voy  a  decir  a  continuación  (¡son  unos  programadores,  además  de
excelentes, muy "quisquillosos"!).

El  objetivo principal  de [i]Symfony2[/i]  no  es tanto  desarrollar otro  framework
[i]PHP[/i],  como desarrollar  un conjunto  de componentes  estables, independientes,
fácilmente acoplables  (que no  acoplados) para  formar sistemas  más complejos,
mediante los cuales se puedan  resolver problemas relacionados con el desarrollo
de aplicaciones  web en  [i]PHP[/i]. Obviamente  no es  necesario utilizar  todos los
componentes  de  [i]Symfony2[/i];  gracias  a su  absoluta  independencia  se  pueden
utilizar  únicamente aquellos  que se  requieran  para resolver  el problema  en
cuestión. [i]Symfony2[/i] se presenta así como una  especie de [i]Lego[/i] en el mundo del
desarrollo en [i]PHP[/i].

Con estos componentes,  uno de los problemas  que se puede resolver es  el de la
creación de  un framework de  desarrollo web. De hecho, uno de los primeros
productos que se han construido con estos componentes ha sido el framework de
desarrollo conocido como [i]Distribución  Standard de Symfony2[/i],  o más  brevemente
[i]Symfony2[/i] sin  más. Y  es precisamente  del estudio de esta distribución de lo que
trata este tutorial.

Así pues, el término  [i]Symfony2[/i] puede referirse a:

1. Los componentes de [i]Symfony2[/i]

2. El framework de [i]Symfony2[/i], conocido como [i]distribución standard de Symfony2[/i].

En el momento en que se escribe este texto, lo más probable es que se trate de lo segundo.

Los componentes de [i]Symfony2[/i], se están  utilizando para otros proyectos (Drupal 8 es un buen ejemplo), y su uso  aumentará cuando dispongan  de una  documentación tan exhaustiva  y bien elaborada como la  que cuenta en estos momentos el  framework [i]Symfony2[/i]. 

En este [url=http://symfony.com/components]enlace[/url] encontrarás una relación de todos los componentes de [i]Symfony2[/i] y su documentación.

Los componentes son las "tripas" del monstruo [i]Symfony2[/i]. No hablaremos mucho más acerca
de estos componentes a lo largo del tutorial. Pero debes saber que existen. Puede que te ayuden a resolver tu próximo proyecto, y muy probablemente sean los ladrillos fundamentales con los que se construyan muchas de las aplicaciones [i]PHP[/i] en un futuro no muy lejano.

[h3]Instalación y configuración de [i]Symfony2[/i][/h3]

A partir de este momento, y mientras no lo especifiquemos explicitamente, cuando hablemos de [i]Symfony2[/i]  nos estamos refiriendo al framework, concretamente a la edición estándard.

En este apartado vamos a instalar y configurar [i]Symfony2[/i], y lo dejaremos listo para construir la aplicación de gestión de alimentos sobre él.

Bájate de [url=http://symfony.com/download]http://symfony.com/download[/url] la última versión de la rama 2.0 de [i]Symfony2[/i]. Verás que hay una modalidad normal y otra [i]without vendor[/i]s. Utiliza la primera. 
    
 [nota] La modalidad normal contiene todas las librerías de terceros ([i]vendors[/i])   necesarias para comenzar a trabajar con el framework, mientras que la modalidad [i]without vendors[/i], como su nombre indica, viene sin estas librerías, razón  por lo que hay que instalarlas posteriormente mediante una herramienta incluida    con [i]Symfony2[/i] ([i]bin/vendors[/i]) que utiliza el sistema de control de versiones   [i]git[/i] para bajar las últimas versiones desde el repositorio de [i]github[/i],  donde se encuentra todo el código de [i]Symfony2[/i]. [/nota]

Descomprime el archivo descargado en algún directorio accesible al servidor web, esto es, dentro de su [i]Document root[/i]. Para que la aplicación funcione, el servidor web debe poder escribir en los directorios [i]app/cache[/i] y [i]app/logs[/i]. Si estás utilizando un sistema operativo tipo [i]UNIX[/i] ([i]Ubuntu[/i], [i]MacOSX[/i], etcétera), la forma más fácil de dar dichos permisos es:
 
[code]chmod -R 777 app/cache app/logs[/code]

  [nota] Durante toda el tutorial suponemos que has hecho esta operación directamente en 
   el [i]Document root[/i] del servidor web, de manera que tendrá la siguiente 
   estructura de directorios:
    
   [code] /var/www/    (o donde tengas mapeado tu Document root)
        |
        &#9492;&#9472;&#9472; Symfony
	    |
	    &#9500;&#9472;&#9472; LICENSE
	    &#9500;&#9472;&#9472; README.md
	    &#9500;&#9472;&#9472; app/
	    &#9500;&#9472;&#9472; bin/
	    &#9500;&#9472;&#9472; deps
	    &#9500;&#9472;&#9472; deps.lock
	    &#9500;&#9472;&#9472; src/
	    &#9500;&#9472;&#9472; vendor/
	    &#9492;&#9472;&#9472; web/[/code]
   
   Y que tanto el servidor web como el servidor de MySQL están instalado en la
   máquina local.[/nota]

A continuación comprobamos que nuestro sistema cumple los requisitos mínimos
ejecutando por la interfaz de comandos la siguiente orden:

[code]php app/check.php[/code]

Si el resultado nos señala algún error, debemos resolverlo antes de continuar. Una vez que pasemos al menos los requisitos obligatorios ([i]mandatory requirements[/i]), podemos ejecutar la demo que viene incorporada en la distribución standard de [i]Symfony2[/i]. Para ello apunta con tu navegador a la siguiente [i]URL[/i]:

[code] http://localhost/Symfony/web/app_dev.php[/code]

¡Y juega un poquito!, Por ejemplo, pica en [i]Run the dem[/i]o y navega por los distintos enlaces. Fíjate en la pinta que tienen las [i]URL[/i]'s. La demo muestra el código que genera las páginas de la propia demo. Fíjate en él detenidamente. Verás que muestra dos partes: el del controlador y el de la plantilla ([i]template[/i]). Es decir, dos elementos del patrón de diseño [i]MVC[/i] (Modelo - Vista - Controlador).

Ya has visto en acción la primera aplicación construida con [i]Symfony2[/i]. Ahora vamos a describir la manera en que [i]Symfony2[/i] organiza el código.

[i]Symfony2[/i] organiza los archivos en dos grupos: los que deben estar directamente accesibles al servidor web ([i]CSS[/i]'s, [i]Javascript[/i], imágenes y el controlador frontal) y los que pueden ser incluidos desde el controlador frontal (librerías [i]PHP[/i] y ficheros de configuración). Los primeros viven en el directorio [i]web[/i], y los segundos, según su funcionalidad, están repartidos entre los directorios [i]app[/i] , [i]src[/i] y [i]vendor[/i]. 

  [nota] En una instalación en un entorno de producción, el [i]Document roo[/i]t del servidor
   web (o del [i]Virtual host[/i] dedicado para la aplicación), debe coincidir con el 
   directorio [i]web[/i], y el resto de directorios deben ubicarse fuera del
   [i]Document root[/i]. No obstante, en un entorno de desarrollo podemos relajarnos y,
   para no andar afinando las configuraciones del servidor web, se puede ubicar todo
   el código dentro del [i]Document root[/i].

   Para paliar el efecto de posibles despistes o malas prácticas por 
   desconocimiento, pereza y otras fatales causas, los directorios [i]src[/i] y
   [i]app[/i], contienen un fichero [i].htacces[/i] que indica al servidor web que
   no debe mostrar su contenido.[/nota]

Veamos ahora para que se utiliza cada uno de estos directorios.

[h4]El directorio web[/h4]

Poco hay que decir ya de este directorio, aquí encontraremos el controlador frontal y todos los [i]assets[/i] de la aplicación: [i]CSS[/i]'s, [i]Javascipts[/i], imágenes, etcétera. 

Esta es la estructura del directorio:

  [code] web
   &#9500;&#9472;&#9472; app_dev.php
   &#9500;&#9472;&#9472; apple-touch-icon.png
   &#9500;&#9472;&#9472; app.php
   &#9500;&#9472;&#9472; bundles
   &#9474;   &#9500;&#9472;&#9472; acmedemo
   &#9474;   &#9500;&#9472;&#9472; framework
   &#9474;   &#9500;&#9472;&#9472; sensiodistribution
   &#9474;   &#9492;&#9472;&#9472; webprofiler
   &#9500;&#9472;&#9472; config.php
   &#9500;&#9472;&#9472; favicon.ico
   &#9492;&#9472;&#9472; robots.txt[/code]

Podemos ver 3 scripts [i]PHP[/i]: 

[list]
[*] [i]config.php[/i] es un script que asiste en la configuración del framework. No  es imprescindible. De hecho cuando uno se siente confortable con Symfony2,  es más sencillo realizar la configuración directamente sobre el código  fuente. Pero para empezar puede servir de ayuda. Si lo utilizas ten en cuenta  los permisos de los ficheros del directorio [i]app/config[/i], pues este script   debe poder escribir allí.

[*] [i]app.php [/i]es el controlador frontal de la aplicación, es decir, es el script  [i]PHP[/i] por el que pasan todas las peticiones. Este script decide el flujo que debe  seguir la aplicación "observando" los parámetros que se hayan  pasado en cada   petición ([i]request[/i]). Un conjunto de parámetros determinado se denomina ruta.   Veamos un ejemplo para aclararlo: en
  
 [code] http://tu.servidor.web/app.php/articulo/1[/code],

 [i] app.php[/i], es el controlador frontal y [i]articulo/1[/i] es una ruta de la aplicación.

[*][i] app_dev.php[/i] también es el controlador frontal de la aplicación. ¿Cómo?  ¿dos controladores frontales? ¡eso no parece encajar con lo que acabamos de decir!.  Bueno tranquilos, tiene su explicación. Se trata de lo que se denomina en   [i]Symfony2[/i] el controlador frontal de [b]desarrollo[/b]. En principio pinta lo  mismo que [i]app.php[/i], pero le añade una barra de depuración que ofrece  muchísima información sobre todo lo relacionado con la ejecución del script.  Puedes ver la barra de depuración en la demo que has ejecutado hace un momento.  Se encuentra abajo de la página. Explórala un poco, te asombrarás de la cantidad  de información que te proporciona. Cuando desarrollamos es muy conveniente  utilizar este controlador frontal, pero en producción NUNCA debe utilizarse,  pues  daríamos a los usuario de la web información que podría comprometer  nuestro sistema.
[/list]

Por otro lado los [i]assets[/i]  se ubicarán en el directorio [i]bundles/nombre_bundle[/i], donde [i]nombre_bundle[/i] es el nombre del [i]bundle[/i] al que pertenece el [i]asset[/i] en cuestión. Vale, ¿y que es un [i]bundle[/i]?, pues por lo pronto quedate con que "es la unidad funcional de código que utiliza [i]Symfony2[/i]". Algo así como una de las piezas del Lego [i]Symfony2[/i]. Más adelante, dedicamos una sección para hablar de estos "personajes" con más detalle.

[h4]El directorio [i]app[/i][/h4]
La finalidad de este directorio es alojar a a los scripts [i]PHP[/i] encargados de los procesos de carga del framework (lo que se conoce como [i]bootstraping[/i]) y a todo lo que tenga que ver con la configuración general de la aplicación. Los archivos de este directorio son los encargados de [i]unir[/i] y dar cohesión a los distintos componentes del framework.

Son especialmente importantes los ficheros [i]autoload.php[/i] y [i]AppKernel.ph[/i], ya que hay que tocarlos cada vez que extendemos el framework con nuevas funcionalidades, es decir cada vez que incorporamos nuevos [i]bundles[/i] (vamos  poniendo en circulación a esta palabreja que usaremos hasta la saciedad). 

En [i]autoload.ph[/i]p se mapean los espacios de nombres contra los directorios en los que residirán las clases pertenecientes a dichos espacios de nombre. De esa manera el proceso de autocarga de clases sabrá donde tiene que buscar las clases cuando se [i]usen[/i] dichos espacios, sin necesidad de incluir explicitamente (esto es, usando [i]include[/i] o [i]require[/i] ) los archivos donde se definen las clases.

En [i]AppKernel.php[/i], se declaran los [i]bundles[/i] que se utilizarán en la aplicación.

En el directorio [i]config[/i] se encuentran los archivos de configuración de la aplicación: [i]config.yml[/i], [i]routing.yml[/i] y [i]security.yml[/i]. 

El sistema de configuración de [i]Symfony2[/i] permite trabajar con distintos entornos de ejecución. Los más típicos son [i]prod[/i], para producción y [i]dev[/i], para desarrollo. Pero se pueden definir tantos entornos como deseemos. 

En el controlador frontal se indica qué entorno deseamos utilizar en la   ejecución del script. Fíjate en la línea 22 de [i]web/app_dev.php[/i], o en la línea 9 del [i]web/app.ph[/i]p:

 [php] ...
   $kernel = new AppKernel('prod', false);
  ...
[/php]

El primer argumento decide el entorno de ejecución que se utilizará. ¿Y para que sirve esto?. [i]Symfony2[/i] utiliza este dato para saber qué ficheros de configuración debe cargar. Supongamos, por ejemplo, que se especifica [i]dev[/i] como entorno de ejecución. Entonces, si existe el fichero [i]config_dev.yml[/i] lo cargará, y si no es así cargará [i]config.yml[/i]. Lo mismo ocurre con los ficheros[i] routing.yml[/i], [i]security.yml[/i] y [i]services.yml[/i]. Más adelante estudiaremos para que sirven cada uno de ellos. Por lo pronto nos conformaremos con saber
la dinámica de funcionamiento. 

Los entornos proporcionan mucha flexibilidad a la hora de desarrollar una aplicación. Vamos a ilustrar con un ejemplo esta flexibilidad. Un caso que nos encontramos habitualmente es que la aplicación que estamos construyendo debe enviar e-mails. Es bastante molesto tener que disponer de cuentas reales y gestionarlas para que podamos probar la aplicación mientras desarrollamos. Podemos utilizar este sistema de configuración para indicar al framework que en el entorno de desarrollo se envíen todos los e-mails a una sola cuenta, o incluso que no se envíen. Otro ejemplo típico podría ser el definir unos parámetros de conexión a la base de datos para el entorno de producción y otro para el de  desarrollo.

Una estrategía muy adecuada para tratar con los ficheros de configuración cuando queremos que haya partes comunes y partes diferentes en cada entorno, es definir todos los parámetros comunes en el fichero [i]fichconfig.ym[/i]l (donde [i]fichconfig[/i] es [i]config[/i], [i]security[/i], [i]routing[/i] o [i]services[/i]), y los particulares de cada entorno en el fichero [i]fichconfig_env.yml[/i] (donde [i]env[/i] es [i]dev[/i],  [i]prod[/i] o cualquier otro nombre de entorno que usemos). Por último importamos los primeros (comunes) desde los últimos (particulares) de la siguiente manera:

Inicio del fichero [i]fichconfig_env.yml[/i]

  [code] imports:
    - { resource: fichconfig.yml }
    ...[/code]

Puedes comprobar que esta es la estrategia utilizada por la distribución standard de [i]Symfony2[/i] con los ficheros [i]config.yml[/i], [i]config_dev.yml[/i] y [i]config_prod.yml[/i].

Para acelerar la ejecución de los scripts, la configuración, el enrutamiento y las plantillas de twig son compiladas y almacenadas en el directorio [i]cache[/i]. Por otro lado, los errores y otra información de interés acerca de eventos que ocurren cuando se ejecuta el framework, son registrados en archivos que se almacenan en el directorio [i]logs[/i]. Por eso [b]estos dos directorios deben tener permisos de escritura para el servidor web[/b].

Por último, en este directorio tan "denso", encontramos la navaja suiza de [i]Symfony2[/i], la aplicación [i]app/console[/i]. Prueba a ejecutarla sin pasarle ningún argumento. Verás una lista con todas las tareas que se pueden lanzar por línea de comandos.

[code] php app/console[/code]

[h4]El directorio ``vendor``[/h4]

Aquí se aloja todo el código funcional que no es tuyo. Es lo que tradicionalmente
se conoce como librerías de terceros. Entre otras cosas, el directorio contiene
los componentes de [i]Symfony2[/i], el ORM [i]Doctrine2[/i] y el sistema de plantillas
[i]twig[/i]. Cuando amplies tu aplicación con nuevos [i]bundles[/i] de terceros instalados 
automáticamente con la aplicación [i]bin/vendors[/i], será aquí donde se ubique el
código.

[h4]El directorio [i]src[/i][/h4]

Es el directorio donde colocarás tu código. Más concretamente: tus [i]bundles[/i].
A base de utilizar este palabro acabarás por asimilarlo antes de que te lo
expliquemos :-).

[h4]El directorio [i]bin[/i][/h4]

El nombre de este directorio es un clásico en el mundo [i]UNIX[/i]. En él se colocan
archivos ejecutables. La distribución standard solo trae el ejecutable [i]vendors[/i]
que se utiliza, en combinación con el fichero [i]deps[/i] (dependencias), para 
instalar componentes de terceros ([i]vendors[/i]).

Y con esto acabamos la descripción de los directorios de [i]Symfony2[/i]. Ha llegado
el momento de hablar de los [i]bundles[/i], esos grandes desconocidos (¡por ahora!).

[h4]Los Bundles: Plugins de primera clase[/h4]

Si los creadores de [i]Symfony2[/i] hubieran elegido la palabra [i]plugin[/i] en lugar de
[i]bundle[/i], es probable que te hubieses hecho una idea más concreta de lo que es
un [i]bundle[/i]. Pues bien, por lo pronto, piensa que un [i]bundle[/i] es un [i]plugin[/i], por
que no es ni más ni menos que eso.

Cualquier framework que se precie debe ofrecer un mecanismo de extensión que 
permita ampliar la aplicación sin compromenter la escalabilidad. Para ello las
piezas que se añaden al sistema deben ser bloques prácticamente autónomos y con
una interfaz sencilla para engancharlos ([i]to plug[/i], en inglés) al sistema. A estos
bloques se les conoce a lo largo y ancho de la galaxia con el nombre de [i]plugin[/i] 
(o complemento, en castellano). ¿Por qué los creadores de [i]Symfony2[/i] han decidido
llamarles [i]bundles[/i] en su lugar? Lo mismo hay alguna razón teórica que se me 
escapa. Pero de lo que si estoy seguro es de que hay una razón histórica:

El antecesor de [i]Symfony2[/i], el fantástico  [i]symfony 1.x[/i] organiza el código en 
[i]aplicaciones[/i], que a su vez están formadas por [i]módulos[/i] con la implementación
de las acciones. Además ofrece un mecanismo de extensión basado en [i]plugins[/i], los 
cuales también organizan el código en [i]módulos[/i] con sus acciones. Pero a pesar 
de este paralelismo las aplicaciones son "más importantes" que los [i]plugins[/i]. De 
hecho, las aplicaciones pueden usar módulos de los [i]plugins[/i], pero lo contrario no
tiene sentido tal y como está organizado [i]symfony 1.x[/i]. Con el tiempo los 
desarrolladores se dieron cuenta de que era más fácil de mantener y organizar los [i]plugins[/i], ya que son bloques de código autónomos y fácilmente acoplables a la 
aplicación. Este hecho llevó de forma natural  a reorganizar la aplicación
colocando todo el código funcional en los [i]plugins[/i]. Las aplicaciones se quedaban 
prácticamente vacías de código y tan solo contenían ficheros de configuración.

Así pues, en [i]Symfony2[/i] decidieron olvidarse del concepto de aplicación (en el 
sentido de [i]symfony 1.x[/i]), y obligar a que todo el código funcional se organizase
en [i]plugins[/i]. Es como hacer a los [i]plugins[/i] ciudadanos de primera clase del 
framework. Finalmente, para evitar cualquier confusión y dirimir la diferencia 
entre [i]plugin[/i] y aplicación, decidieron usar la palabra [i]bundle[/i]. Y eso es todo.
Si no conoces [i]symfony 1.x[/i], seguro que hubieras preferido llamarle [i]plugin[/i].
 Y si lo conoces es probable que también.

En fin, lo que realmente debes saber:
[nota] Un [i]bundle[/i] no es más que un directorio que aloja todo aquello relativo a una 
 funcionalidad determinada. Puede incluir clases [i]PHP[/i], plantillas,   configuraciones, [i]CSS's[/i] y [i]Javascript[/i].[/nota]

[h3]La aplicación [b]gestión de alimentos[/b] en [i]Symfony2[/i][/h3]

Y llegó el momento de ponerse a cocinar código.

[h4]Generación de un [i]Bundle[/i][/h4]

La primera idea que debe quedar clara, expresada de manera simplista, es que 
"[b]todo es un bundle[/b]" en [i]Symfony2[/i]. Por tanto, si queremos desarrollar una
aplicación necesitaremos, por lo menos, tener un [i]bundle[/i] para alojar el código de
la misma. Comencemos por ahí. El siguiente comando de [i]Symfony2[/i] nos ayuda a 
generar el esqueleto de un bundle de manera interactiva:
 
[code] php app/console generate:bundle[/code]
   
A cada pregunta que nos hace le acompaña una pequeña ayuda. En primer lugar nos
pregunta por el espacio de nombre que compartiran las clases del [i]bundle[/i]. La 
recomendación, como se dice en el texto de ayuda del comando, es que comience por
el nombre del fabricante del [i]bundle[/i], el nombre del proyecto o del cliente, 
seguido, opcionalemente, por una o más categorías, y finalizar con el nombre del
[i]bundle[/i] seguido del sufijo [i]Bundle[/i]. Es decir el nombre completo del espacio
de nombres del [i]bundle[/i] debe seguir el siguiente patrón:

[code]Fabricante/categoria1/categoria2/../categoriaN/nombrebundleBundle[/code]

Ilustremos esto con varios ejemplos de nombres de [i]bundles[/i] válidos:

 [code]  AulasMentor/AlimentosBundle
   AulasMentor/Tutorial/AlimentosBundle
   AulasMentor/CursoSf2/Tutorial/AlimentosBundle
   Jazzyweb/AulasMentor/AlimentosBundle[/code]

Nos quedaremos con el último de los nombres para el bundle que vamos a 
construir. Con este nombre se quiere expresar algo así [i]como[/i] que el [i]bundle[/i]
[i]AlimentosBundle[/i] ha sido creado por [i]Jazzyweb[/i] (una empresa ficticia) para
el cliente [i]AulasMentor[/i]. Como ves, cualquier nombre vale siempre que contenga
un nombre de fabricante ([i]vendor name[/i]) y un nombre de [i]bundle[/i]. En medio podemos
poner lo que queramos para organizar nuestro trabajo.

Introduce [i]Jazzyweb/AulasMentor/AlimentosBundle[/i] como espacio de nombres del 
[i]bundle[/i]. A continuación nos pregunta por el nombre del [i]bundle[/i]. Y nos ofrece
una recomendación que es el mismo nombre del espacio de nombres anterior pero sin
los separadores " /". El nombre del [i]bundle[/i] es importante pues, en ocasiones, 
hay que referirse al [i]bundle[/i] por este nombre.

Presiona [i]enter[/i] para aceptar la sugerencia.

El próximo paso es asignarle una ubicación en la estructura de directorios del proyecto. La flexibilidad de [i]Symfony2[/i] permite que lo coloques donde quieras.Pero es muy recomendable que lo coloques en el directorio [i]src[/i], ya que está pensado para alojar nuestro código. Si lo haces así, te ahorrarás tener que incluir una línea de código en el fichero [i]app/autoload.php[/i] para registrar elespacio de nombre en el sistema de autocarga de clases. Esto último es así porque en dicho fichero ya se ha contemplado que todas las clases que se aloje en [i]src[/i]
sean autocargadas asignándole como espacio de nombre raíz el mismo nombre que la estructura de directorios computada desde [i]src[/i]. 

Presiona [i]enter[/i] para aceptar la sugerencia. Cuando termines de generar el *[i]bundle[/i]* verás como se ha creado en [i]src[/i] el directorio [i]Jazzyweb/AulasMentor/AlimentosBundle[/i], es decir un directorio que tiene lamisma estructura que el espacio de nombres que hemos asignado al [i]bundle[/i]. Estoes lo que se quiere decir de manera genérica en el párrafo anterior.

Los [i]bundles[/i] llevarán asociados algo de configuración. Como mínimo será necesario configurar las rutas que mapean las [i]URL[/i]'s en acciones del [i]bundle[/i]. [i]Symfony2[/i] admite 4 formas de representar las configuraciones: con ficheros [i]XML[/i], [i]YML[/i] o [i]PHP[/i], y mediante anotaciones, que es una manera de expresar parámetros de configuración en el propio código funcional aprovechando para ello los comentarios de [i]PHP[/i].

Más adelante tendremos ocasión de utilizar las anotaciones y las entenderás mejor. Llegados a este punto hemos de decir que la elección es una cuestión de gusto; discutir con alguien acerca de cual es la mejor opción sería una pérdida de tiempo. Para el caso de la configuración de los [i]bundles[/i] (prácticamente para definir rutas como veremos después) hemos elegido los fichero [i]YAML[/i] como formato para la configuración.

Selecciona (escribe) [i]yml[/i] como formato de configuración.

Por último contesta [i]yes[/i] a la pregunta de si quieres generar la estructura completa. Esta opción generará algunos directorios y archivos extra que siguen las recomendaciones de [i]Symfony2[/i] para alojar código. Es posible que no los utilices, pero no hacen "daño" y sugieren como debe organizarse el código. No obstante el programador tiene bastante libertad a la hora de organizar los archivos del [i]bundle[/i] como quiera.

Confirma la generación del código. Una vez generado, el asistente te realizará dos preguntas más. Primera pregunta: ¿quieres actualizar automáticamente el [i]Kernel[/i]? y segunda pregunta ¿quieres actualizar directamente el [i]routing[/i]? Contesta a las dos afirmativamente. Vamos a ver con más detalle las consecuencias de estas actualizaciones automáticas.

Por una parte el [i]bundle[/i], como ya hemos explicado, es un bloque desacoplado y reutilizable de código que agrupa a una serie de funcionalidades. Si queremos utilizarlo en nuestro proyecto debemos "notificarlo" al framework. Es decir, hemos de "engancharlo". Esto se hace registrándolo en el archivo [i]app/AppKernel.php[/i]. La primera actualización automática ha realizado dicho registro. Abre ese archivo y fíjate como al final del método [i]registerBundles()[/i]
aparece la siguiente línea:

[php]   ...
   new Jazzyweb\AulasMentor\AlimentosBundle\JazzywebAulasMentorAlimentosBundle(),
   ...
[/php]

Dicha línea ha sido insertada automáticamente como consecuencia de haber respondido afirmativamente a la primera pregunta. El cometido de la línea es registrar el [i]bundle[/i] recien creado en el framework para poder hacer uso del mismo.

La segunda actualización automática "enlaza" la tabla enrutamiento general de la aplicación con la tabla de enrutamiento particular del [i]bundle[/i]. La tabla de enrutamiento es la responsable de indicar al framework como deben mapearse las [i]URL[/i]'s en acciones [i]PHP[/i]. Para ver como se ha realizado este enlace mira el fichero [i]app/config/routing.yml[/i]:

  [code] JazzywebAulasMentorAlimentosBundle:
    resource: "@JazzywebAulasMentorAlimentosBundle/Resources/config/routing.yml"
    prefix:   /[/code]

Estas líneas han sido introducidas automáticamente como consecuencia de contestar afirmativamente a la segunda pregunta. Observa que el apartado [i]resource[/i] es la dirección en el sistema de ficheros de la tabla de enrutamiento propia del [i]bundle[/i] que acabamos de crear. [i]Symfony2[/i] sabe convertir [i]@JazzywebAulasMentorAlimentosBundle[/i] en la ubicación del  [i]bundle[/i] pues está debidamente registrado. 

Es importante que conozcas como se acopla un [i]bundle[/i] a la aplicación, pues si falla la actualización automática del [i]KernelApp.php[/i] y/o del [i]routing.yml[/i], debes realizarlas manualmente.

Ahora puedes echarle un vistazo al fichero [i]routing.yml[/i] del [i]bundle[/i] ([i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/config/routing.yml[/i]). Verás que existe una ruta mapeada contra una acción. Después explicaremos los detalles de la ruta. Esta última ruta sirve para probar el [i]bundle[/i]. Así que accede desde tu navegador web a la siguiente [i]URL[/i] (que es la que se corresponde con esta ruta de prueba)
   
   [code]http://localhost/Symfony/web/app_dev.php/hello/alberto[/code]
   
Si todo va bien, obtendrás como respuesta un saludo. Puedes cambiar el nombre del final de la ruta.

Resumiendo: Para desarrollar nuestra aplicación hemos de contar al menos con un [i]bundle[/i] para escribir el código. Según la complejidad de la aplicación será más o menos adecuado organizar el código en varios [i]bundles[/i]. El criterio a seguir es el de agrupar en cada [i]bundle[/i] funcionalidades similares o del mismo tipo.

Los bundles son bloques desacoplados y tienen asociado un espacio de nombre. Para acoplar un bundle al framework hay que :

1. Registrar el espacio de nombre en el sistema de autocarga (fichero    ``app/autoload.php``. Este paso no es necesario si ubicamos al *bundle* en el   directorio ``src``.

2. Registrar al bundle en el fichero [i]app/AppKernel.php[/i]. Esta operación se  puede hacer automáticamente a través del generador interactivo de [i]bundles[/i],   pero si fallase por alguna razón (por ejemplo que los permisos de dicho archivo   no estén bien definidos). Habría que hacerlo a mano.

3. Importar las tablas de enrutamiento del [i]bundle[/i] en la tabla de enrutamiento   de la aplicación.

[h4]Anatomía de un [i]Bundle[/i][/h4]

Si has seguido las indicaciones que hemos dado en este tutorial, debes tener en tu directorio [i]src[/i] dos directorios: [i]Jazzyweb[/i] y [i]Acme[/i] . El primero se corresponde con el [i]bundle[/i] que acabamos de crear, y el segundo es un ejemplo que viene de serie con la distribución standard de [i]Symfony2[/i] y que contiene el código de la demo con la que has jugado hace un rato. Vamos a utilizar este último para realizar la [b]disección[/b] de un [i]bundle[/i], ya que está más rellenito de código  que nuestro recien horneado y esquelético [i]bundle[/i]. 

    [code]Acme/
    &#9492;&#9472;&#9472; DemoBundle
	&#9500;&#9472;&#9472; AcmeDemoBundle.php
	&#9500;&#9472;&#9472; Controller
	&#9474;   &#9500;&#9472;&#9472; DemoController.php
	&#9474;   &#9500;&#9472;&#9472; SecuredController.php
	&#9474;   &#9492;&#9472;&#9472; WelcomeController.php
	&#9500;&#9472;&#9472; ControllerListener.php
	&#9500;&#9472;&#9472; DependencyInjection
	&#9474;   &#9492;&#9472;&#9472; AcmeDemoExtension.php
	&#9500;&#9472;&#9472; Form
	&#9474;   &#9492;&#9472;&#9472; ContactType.php
	&#9500;&#9472;&#9472; Resources
	&#9474;   &#9500;&#9472;&#9472; config
	&#9474;   &#9474;   &#9492;&#9472;&#9472; services.xml
	&#9474;   &#9500;&#9472;&#9472; public
	&#9474;   &#9474;   &#9500;&#9472;&#9472; css
	&#9474;   &#9474;   &#9474;   &#9492;&#9472;&#9472; demo.css
	&#9474;   &#9474;   &#9492;&#9472;&#9472; images
	&#9474;   &#9474;       &#9500;&#9472;&#9472; blue-arrow.png
	&#9474;   &#9474;       &#9500;&#9472;&#9472; field-background.gif
	&#9474;   &#9474;       &#9500;&#9472;&#9472; logo.gif
	&#9474;   &#9474;       &#9500;&#9472;&#9472; search.png
	&#9474;   &#9474;       &#9500;&#9472;&#9472; welcome-configure.gif
	&#9474;   &#9474;       &#9500;&#9472;&#9472; welcome-demo.gif
	&#9474;   &#9474;       &#9492;&#9472;&#9472; welcome-quick-tour.gif
	&#9474;   &#9492;&#9472;&#9472; views
	&#9474;       &#9500;&#9472;&#9472; Demo
	&#9474;       &#9474;   &#9500;&#9472;&#9472; contact.html.twig
	&#9474;       &#9474;   &#9500;&#9472;&#9472; hello.html.twig
	&#9474;       &#9474;   &#9492;&#9472;&#9472; index.html.twig
	&#9474;       &#9500;&#9472;&#9472; layout.html.twig
	&#9474;       &#9500;&#9472;&#9472; Secured
	&#9474;       &#9474;   &#9500;&#9472;&#9472; helloadmin.html.twig
	&#9474;       &#9474;   &#9500;&#9472;&#9472; hello.html.twig
	&#9474;       &#9474;   &#9500;&#9472;&#9472; layout.html.twig
	&#9474;       &#9474;   &#9492;&#9472;&#9472; login.html.twig
	&#9474;       &#9492;&#9472;&#9472; Welcome
	&#9474;           &#9492;&#9472;&#9472; index.html.twig
	&#9500;&#9472;&#9472; Tests
	&#9474;   &#9492;&#9472;&#9472; Controller
	&#9474;       &#9492;&#9472;&#9472; DemoControllerTest.php
	&#9492;&#9472;&#9472; Twig
	    &#9492;&#9472;&#9472; Extension
		&#9492;&#9472;&#9472; DemoExtension.php[/code]
[list]


[*] [i]AcmeDemoBundle.php[/i] es una clase que extiende a   [i]Symfony\Component\HttpKernel\Bundle\Bundle[/i] y que define al [i]bundle[/i].   Se utiliza en el proceso de registro del mismo (recuerda, en el fichero   [i]app/AppKernel.php[/i]). Todos los [i]bundles[/i] deben incorporar esta clase (bueno,  el nombre cambiará según el nombre del [i]bundle[/i]).

[*] [i]Controller[/i] es el directorio donde se deben colocar los controladores con las  distintas acciones del [i]bundle[/i]. Las acciones son las funciones (o métodos)  Lo lógico y recomendado, es crear una clase  [i]Controller[/i] por cada grupo de funcionalidades. Pero no es una exigencia, si   quieres puedes colocar todas tus acciones en el mismo controlador. Cuando se  genera un [i]bundle[/i] se crea el controlador [i]DefaultController[/i].

[*] [i]Dependency Injection[/i]. Una de las características más sobresaliente de   *[i]Symfony2[/i]* es el uso intensivo que hace de la *[i]Inyección de Dependencias[/i]*, un  potente patrón de diseño mediante el que se facilita la creación y configuración  de objetos que prestan servicios en una aplicación gracias a la gestión   automática de sus dependencias. Contribuye a crear un código más  desacoplado y  coherente. En este [url=http://juandarodriguez.es/tutoriales-2/inyeccion-de-dependencias-en-symfony2/]tutorial[/url] se explica con bastante detalle como se trata la Inyección de dependencias en [i]Symfony2[/i]. Aunque no es un patrón complicado, es  dificil de explicar con precisión y  claridad.   [i]Symfony2[/i] nos ofrece dos maneras de "cargar" la configuración de las   dependencias y los servicios creados. Una más sencilla y directa, y otra más  elaborada y apropiada para el caso en que nuestro [i]bundle[/i] vaya a ser   distribuido con la intención de que se utilice en otros proyectos [i]Symfony2[/i]. En  este directorio se ubican las  clases relacionadas con este segundo método de  gestionar las dependencias.

[*] [i]Resources[/i], es decir, recursos. Entendemos por recursos: los ficheros de   configuración del [i]bundle[/i] (directorio [i]config[/i]), los [i]assets[/i] que requiere  el [i]bundle[/i] para enviar en sus respuestas (directorio [i]public[/i]) y las   plantillas con las que se [i]renderizan[/i] (pintan) el resultado de las acciones de  los controladores (directorio [i]view[/i]). Fíjate como en este [i]bundle[/i],  las plantillas están  organizadas en tres directorios ([i]Demo[/i], [i]Secured[/i] y   [i]Welcome[/i]) cuyos nombres coinciden con los de los controladores.   

[*] [i]Test[/i], es el directorio donde viven las pruebas unitarias y funcionales del  [i]bundle[/i].

[/list]

Estos son los directorios más típicos de cualquier [i]bundle[/i], de hecho son los que se generan automáticamente con el comando [i]app/console generate:bundle[/i]. Sin embargo un [i]bundle[/i] puede tener muchos más directorios y ficheros, organizados como su creador crea conveniente. En el caso del [i]bundle[/i] [i]AcmeDemoBundle[/i], puedes ver los siguientes "extras":

[list]
[*] [i]Form[/i] es el directorio donde se colocarán las clases que definen los   formularios de la aplicación.

[*] [i]ControllerListener.php[/i]  describe un [i]event listener[/i] que es un mecanismo muy   adecuado de extender y alterar el flujo del framework sin  tener que tocar el   código original del componente del framework que utiliza dicho sistema. Se trata   de una característica avanzada de [i]Symfony2[/i] raramente utilizada cuando uno se  esta iniciando.

[*] [i]Twig[/i] es un directorio propio de este [i]bundle[/i], en el que se ha implementado  una extensión del sistema de plantillas.
  
[/list]

Ahora ya nos encontramos con un mínimo bagaje para emprender el desarrollo del [i]bundle[/i]  [i]JazzywebAulasMentorAlimentosBundle[/i] y, por tanto de la aplicación.



[h4]Flujo básico de creación de páginas en [i]Symfony2[/i][/h4]

La creación de páginas web con [i]Symfony2[/i] involucra tres pasos:

1. Creación de la ruta que mapea la [i]URL[/i] de la página en una acción de algún    controlador. Dicha ruta se registra en el archivo    [i]config/Resources/routing.yml[/i] del [i]bundle[/i], que a su vez debe estar   correctamente importado en el archivo de rutas general de la aplicación   [i]app/config/routing[/i].

2. Creación de dicha acción en el controlador correspondiente. La acción, haciendo   uso del modelo, realizará las operaciones necesarias y obtendrá los datos crudos   ([i]raw[/i]), es decir sin ningún tipo de formato, que facilitará a una plantilla para   ser pintados (renderizados). El código de los controladores debe ubicarse en   el directorio [i]Controllers[/i] del [i]bundle[/i].
   
3. Creación de dicha plantilla. Esto se hace en el directorio [i]Resources/view[/i].    Con el fin de organizar bien las plantillas, es recomendable crear un    directorio con el nombre de cada controlador. También es muy recomendable  utilizar [i]Twig[/i] como sistema de plantillas, aunque también se puede utilizar   [i]PHP[/i].

Estos pasos son, por supuesto, una guía general y mínima que debemos seguir en la creación de las páginas de nuestra aplicación. No obstante, en muchos casos tendremos que realizar otras operaciones que se salen de este flujo y que tienen que ver más con la construcción del modelo de la aplicación.

[h4]Definición de las rutas del [i]bundle[/i][/h4]

Ya hemos visto que en [i]Symfony2[/i] todas las peticiones a la aplicación se realizan a través de un script [i]PHP[/i] que se llama controlador frontal ([i]app.php[/i]). Este script "sabe" lo que debe devolver como respuesta al usuario "mirando" la *ruta* que lo acompaña en cada petición. 

Cada ruta en [i]Symfony2[/i] consiste en un conjunto de parámetros separados por el caracter "/". Ejemplos de [i]URL[/i]'s con rutas de [i]Symfony2[/i]  serían:

  [code] http://tu.servidor/app.php
   http://tu.servidor/app.php/listar
   http://tu.servidor/app.php/ver/4[/code]

Las rutas correspondientes serían:

  [code] 
   /
   /listar
   /ver/4[/code]

Es decir, los parámetros que siguen al controlador frontal. Esta forma de pasar parámetros a través de la [i]URL[/i] mejora en varios aspectos a la clásica [i]query string[/i] del tipo:

 [code]?param1=val1&param2=val2&...&paramN=valN[/code]

En primer lugar el usuario que utiliza el navegador “siente” que la [i]URL[/i] que aparece en la barra de direcciones forma parte de la aplicación que está utilizando. Por tanto, cualquier [i]URL[/i] llena de carácteres extraños y demasiado larga redunda en una degradación estética. En segundo lugar y más allá de cuestiones estéticas, cuando utilizamos query strings clásicas estamos dando información innecesaria al usuario, ya que el nombre de los parámetros ([i]paramX[/i]) es algo que tiene sentido únicamente para la aplicación en el servidor. Esta información extra, además de dar lugar a [i]URL[/i]’s horribles, supone un problema de seguridad, ya que el usuario podría utilizarlas para sacar conclusiones acerca de la aplicación y utilizarla para comprometerla.

El aspecto de las [i]URL[/i]'s puede mejorar aún más si utilizamos el módulo [i]Rewrite[/i] del servidor web, ya que también podemos eliminar el nombre del controlador frontal  [i]app.php[/i]). Así además de mejorar el estilo de la [i]URL[/i], ocultamos al usuario información acerca del lenguaje de programación que estamos utilizando en el servidor.

Nos quedarían [i]URL[/i]'s de este tipo:

   [code]http://tu.servidor/
   http://tu.servidor/listar
   http://tu.servidor/ver/4[/code]

¡Mucho más legibles y elegantes!

[nota]En el directorio ``web`` existe un fichero ``.htaccess`` con el siguiente contenido:
      
      [code]<IfModule mod_rewrite.c>
        RewriteEngine On
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^(.*)$ app.php [QSA,L]
      </IfModule>[/code]
   
 La función de dicho fichero es, precisamente, reescribir las rutas anteponiendo   ``app.php``, de manera que no sea necesario especificar el controlador frontal  en la *URL*. Para que esto funcione es necesario que el servidor web tenga   instalado el módulo ``Rewrite``, y permita el cambio de directivas a través  de ficheros ``.htaccess``. [/nota]

La siguiente tabla muestra las rutas que definiremos en nuestra aplicación y la acción que deben disparar.

[code]
/          (mostrar pantalla inicio)
/listar    (listar alimentos)
/insertar  (insertar un alimento)
/buscar    (buscar alimentos)
/ver/x     (ver el alimento x)
[/code]

En [i]Symfony2[/i] las rutas se definen en el archivo [i]app/config/routing.ym[/i]l. Para que los [i]bundles[/i] no pierdan la autonomía que debe caracterizarlos, las rutas que se mapean en un controlador de un determinado [i]bundle[/i] deberían definirse dentro del propio [i]bundle[/i]. Concretamente en el archivo [i]Resources/config/routing.yml[/i] del [i]bundle[/i]. Y para hacerlas disponibles a la aplicación, se importa este último fichero en [i]app/config/routing.yml[/i].

[nota]
 Aunque el sitio recomendado para ubicar el fichero [i]routing.yml[/i] de un  [i]bundle[/i] es [i]Resources/config[/i], [i]Symfony2[/i] no lo exige, ya que en el archivo [i]app/config/routing.yml[/i], que es el que realmente define las rutas, puedes   indicar la ruta concreta de los archivos que se quieren importar.
[/nota]
   
Abre el archivo [i]src/Jazzyweb/AulasMentor/AlimentosBunle/Resources/config/routing.yml[/i]
y borra las siguientes líneas:

  [code] 
JazzywebAulasMentorAlimentosBundle_homepage:
    pattern:  /hello/{name}
    defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:index }[/code]

Las líneas que acabas de borrar definían la ruta de la acción de ejemplo que se crea automáticamente al generar el bundle. Fíjate en la estructura de la definición de una ruta; consisten en un identificador de la ruta ([i]JazzywebAulasMentorAlimentosBundle_homepage[/i]), 
que puede ser cualquiera siempre que sea único en todo el framework, el patrón de la ruta ([i]pattern: /hello/{name}[/i]), que describe la estructura de la ruta, y la declaración del controlador sobre el que se mapea la ruta ([i]defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:index }[/i]).

Creamos nuestra primera ruta añadiendo al archivo anterior lo siguiente:

   [code]JAMAB_homepage:
    pattern:  /
    defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:index }[/code]
   
Como el nombre de la ruta debe ser único en toda la aplicación, es una buena práctica nombrarlas anteponiendo un prefijo con el nombre del [i]bundle[/i], o con algo que lo identifique. Como el nombre de nuestro [i]bundle[/i] es muy largo, hemos optado por usar como prefijo las siglas [i]JAMAB[/i].

Una vez definida la ruta debemos implementar la acción del controlador especificada en la misma, es decir [i]JazzywebAulasMentorAlimentosBundle:Default:index[/i]. 

[nota]
   Fíjate en el patrón que se utiliza para especificar la acción del controlador:    [i]JazzywebAulasMentorAlimentosBundle:Default:index[/i]. A esto se le llama en   [i]Symfony2[/i] un nombre lógico. Está compuesto por el nombre del [i]bundle[/i], el   nombre del controlador, y el nombre de la acción separados por el caracter   ":". En este caso, el nombre lógico hace referencia a el método   [i]indexAction()[/i] de una clase [i]PHP[/i] llamada  [i]Jazzyweb\AulasMentor\AlimentosBundle\Controller\DefaultController[/i].   Es decir, hay que añadir el sufijo [i]Controller[/i] al nombre del controlador, y   el sufijo [i]Action[/i] al nombre de la acción.
[/nota] 

[h4]Creación de la acción en el controlador[/h4]
  
Editamos el fichero [i]src/Jazzyweb/AulasMentor/AlimentosBundle/Controller/DefaultController.php[/i], y reescribimos el método [i]indexAction()[/i]:
  
 [php] <?php
    
    namespace Jazzyweb\AulasMentor\AlimentosBundle\Controller;
    
    use Symfony\Bundle\FrameworkBundle\Controller\Controller;
    
    class DefaultController extends Controller
    {
        
        public function indexAction()
        {
            $params = array(
                'mensaje' => 'Bienvenido al curso de Symfony2',
                'fecha' => date('d-m-yyy'),
            );
            
            return $this->render('JazzywebAulasMentorAlimentosBundle:Default:index.html.twig',
            $params);
        }
    }[/php]
   
Analicemos  el código  anterior.  La clase  [i]DefaultController[/i]  "vive" en  el espacio de  nombres [i]Jazzyweb\AulasMentor\AlimentosBundle\Controller[/i],  por lo que               su               nombre              completo               es [i]Jazzyweb\AulasMentor\AlimentosBundle\Controller\DefaultController[/i].  La clase extiende  de  [i]Symfony\Bundle\FrameworkBundle\Controller\Controller[/i], la  cual forma parte de  [i]Symfony2[/i] y, aunque no es necesario  que nuestros controladores deriven de dicha clase, si lo hacemos nos facilitará mucho  la vida, ya que esta clase base cuenta con potentes herramientas  para trabajar  con [i]Symfony2[/i].   Posiblemente  la más  útil sea  el  [i]Contenedor de  Dependencias[/i] tambien  conocido como [i]Contenedor  de Servicios[/i], con el que podemos obtener  fácilmente instancias bien configuradas de cualquier servicio del framework, tanto de los incluidos en la distribución estándard, como de  los que  nosotros creemos  o de los  que se  añadan en  las extensiones  de terceros ([i]vendors[/i])  que podamos instalar. Quédate tranquilo  con esto  de los servicios pues será un tema que abordaremos más adelante. Por lo pronto es suficiente con que sepas que los servicios son objetos  ofrecidos por el  framework para realizar determinadas  tareas (como por ejemplo enviar  emails o  manipular una base de datos).

[nota]
    [b]Sobre los espacios de nombre de PHP 5.3[/b]
    Si en la línea 7 se utiliza únicamente el nombre [i]Controller[/i] en lugar del    nombre completo [i]Symfony\Bundle\FrameworkBundle\Controller\Controller[/i],    es por que previamente, en la línea 5, se ha indicado en el archivo que se    va a utilizar la clase [i]Controller[/i] de dicho espacio de nombre.[/nota]

El método [i]indexAction()[/i] es una [b]acción[/b] , es decir, un método que está mapeado en una [i]URL[/i] a través de una ruta. Dichas rutas se definen en un fichero, que utilizarás intensivamente cuando desarrollas aplicaciones con [i]Symfony2[/i], denominado [i]routing.yml[/i]. La  acción [i]indexAction()[/i] define un  array asociativo con los datos "crudos" (raw) [i]mensaje[/i] y [i]fecha[/i], y se los pasa a una plantilla para que  los  pinte. Esto  último  se  hace en  la  línea  17 utilizando  el  método [i]render[/i]  de  la  clase padre [i]Symfony\Bundle\FrameworkBundle\Controller\Controller[/i]. Este método recibe dos argumentos,  el  primero es  el  nombre  lógico de  la  plantilla  que se  desea utilizar,   y   el   segundo   es   un   array   asociativo   con   los   datos.

Las acciones terminan con la devolución de un objeto [i]Response[/i]. Precisamente, el método [i]render[/i] convierte una plantilla en un objeto de este tipo.

El  método [i]render[/i]  es uno  de los  servicios disponibles  en el  framework y accesible       desde       cualquier       clase      que       derive       de [i]Symfony\Bundle\FrameworkBundle\Controller\Controller[/i].  Es  un  servicio  que usaremos hasta  la saciedad. El  nombre lógico de  una plantilla, es  similar al nombre lógico  de un controlador;  está compuesto por  el nombre del  bundle, el nombre   del  directorio   que   aloja   a  la   plantilla   en  el   directorio [i]Resources/view[/i] (que suele  coincidir con el nombre del  controlador, en este caso [i]Default[/i]), y el nombre del  archivo que implementa la plantilla (en este caso  [i]index.html.twig[/i]).    Es     decir    que     el    nombre     lógico:

[i]JazzywebAulasMentorAlimentosBundle:Default:index.html.twig[/i],  hace referencia al   archivo [i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/Default/index.html.twig[/i].         

[h4]Creación de la plantilla[/h4]

Siguiendo los pasos  para la creación de una página  en [i]Symfony2[/i], lo siguiente que   tenemos   que   hacer   es   crear  la   plantilla.   Edita   el   fichero [i]src/Jazzyweb/AulasMentor AlimentosBundle/Resources/view/Default/index.html.twig[/i] con el siguiente contenido:

[code]<h1>Inicio</h1>
   <h3> Fecha: {{fecha}}  </h3>
   {{mensaje}}[/code]
   
Aunque [i]Symfony2[/i]  permite el uso de  [i]PHP[/i] como sistema de  plantillas, en este tutorial  utilizaremos  [i]Twig[/i],  que  es lo  recomendado  oficialmente.  El  código anterior es una plantilla  [i]twig[/i].

En  [i]twig[/i], el  contenido dinámico,  es  decir, los  datos "crudos"  que le  son pasados desde el controlador (segundo argumento del método [i]render[/i] en la acción [i]indexAction()[/i]), se referencian con dobles llaves ([i]{{ dato }}[/i]).  En el ejemplo anterior [i]{{ fecha }}[/i] hace referencia al elemento [i]fecha[/i] del array construido en  el controlador, y [i]{{ mensaje }}[/i],  como ya has deducido, al elemento [i]mensaje[/i] de dicho array.

Pues  con  esto hemos  terminado.  Vamos  a probar  lo  que  acabamos de  hacer. Introduce en la barra de direcciones  de tu navegador la [i]URL[/i] correspondiente a la  ruta  que   acabamos  de  crear.  Utiliza  el   controlador  de  desarrollo:
 
  [code]http://localhost/Symfony/web/app_dev.php/[/code]

¡Vaya! parece que nada de lo que hemos hecho ha funcionado. Vuelve a aparecer la aplicación demo de [i]Symfony2[/i].

Ahora prueba con el controlador de producción:

[code]   http://localhost/Symfony/web/app.php/[/code]

¡Ahora si! Vemos la pantalla de  inicio de nuestro [i]bundle[/i]. Pero entonces, ¿qué está pansando?  las rutas tienen  distinto sentido según el  controlador frontal que usemos.  ¿Por qué?. La respuesta  a este comportamiento se  encuentra en las distintas configuraciones  que se  cargan en función  del entorno  de ejecución. Cuando utilizamos el controlador frontal de desarrollo [i]app_dev.php[/i], se carga el fichero de  routing [i]app/config/routing_dev.php[/i]. Si le echas  un vistazo al fichero verás que comienza con la siguiente ruta:

   [code] _welcome:
	pattern:  /
	defaults: { _controller: AcmeDemoBundle:Welcome:index }[/code]

La cual colisiona con la que nosotros hemos  creado, ya que el patrón de la ruta es el  mismo: "/". El sistema  de enrutamiento de [i]Symfony2[/i]  va leyendo todas las rutas  y cuando encuentra una  que coincide con  la [i]URL[/i] que se  ha pedido, ejecuta la acción asociada. No sigue leyendo  más rutas. Por eso, si en un mismo proyecto hay dos rutas, o más precisamente, dos patrones de rutas que coincidan, se ejecutará la primera que se encuentre. Atención por que no se producirá ningún error. Esto hay que tenerlo muy en cuenta cuando se desarrolla  con [i]Symfony2[/i]  para evitarnos  algún que  otro dolor  de cabeza.

En el  caso del controlador frontal  de producción, el framework  lee el fichero [i]routing.yml[/i], ya que no existe [i]routing_prod.yml[/i]. Mira el fichero y podrás comprobar que no hay  ninguna ruta que colisione con la  que nosotros hemos definido. Por tanto todo está bien y se ejecuta la acción correcta.

Una vez que sabemos las causas del problema, si queremos que el controlador de desarrollo cargue la ruta de nuestro [i]bundle[/i], cualquier solución que propongamos pasa por evitar la colisión entre rutas. Y para ello podemos hacer varias cosas:

1. Deshabilitar el plugin *[i]AcmeDemoBundle[/i]* y sus rutas.

2. Cambiar el patrón de las rutas del plugin [i]AcmeDemoBundle[/i], anteponiendole   a todas ellas un prefijo ([i]acme[/i], por ejemplo)

3. Cambiar el patrón de las rutas del   [i]Jazzyweb/AulasMentorAlimentosBundle[/i],   anteponiéndole a todas ellas un prefijo ([i]alimentos[/i], por ejemplo)

Con el fin  de ilustrar una carácteristica del sistema  de routing, hemos optado por la 3ª solución. Podemos añadir un prefijo a todas las rutas del [i]bundle[/i] sin más  que cambiar  el parámetro  [i]prefix[/i] en  la ruta  importada en  el archivo [i]app/config/routing.yml[/i]:

  [code] JazzywebAulasMentorAlimentosBundle:
     resource: "@JazzywebAulasMentorAlimentosBundle/Resources/config/routing.yml"
     prefix:   /alimentos[/code]
 
Ahora, para ver la página de inicio de nuestro *bundle*, apuntamos nuestro navegador a:

  [code] http:://localhost/app_dev.php/alimentos/[/code]

Y ya está! A partir de ahora todas las rutas de nuestro [i]bundle[/i] llevarán el prefijo [i]alimentos[/i] delante.
 
 [nota]  Como hemos cambiado un fichero de configuración, para que el cambio se haga
   efectivo en el entorno de producción hay que borrar la caché con el siguiente
   comando:

   
    [code]  # app/console  cache:clear --env=prod[/code]
[/nota]

[h4]Decoración de la plantilla con un layout[/h4]

Te habrás dado cuenta que hemos pintado un bloque [i]HTML[/i] incompleto. Si no te has percatado de ello mira el código fuente [i]HTML[/i] que llega al navegador. Nos falta someter a la plantilla al proceso de decoración, mediante el cual se le añade funcionalidad. En el caso de la aplicación de [i]gestión de alimentos[/i] hay que añadir la cabecera con el menú, el pie de página y los estilos.

[nota]
   Sobre el proceso de decoración:

   En una aplicación web,  muchas de las páginas tienen elementos comunes. Por    ejemplo, un caso típico es la cabecera (donde se coloca el mensaje de bienvenida),   el menú y el pie de página. Este hecho, y la aplicación del conocido principio de   buenas prácticas de programación [i]DRY[/i] ([i]Don't Repeat Yourself[/i], No Te Repitas),   lleva a que cualquier sistema de plantillas que se utilice para implementar la   vista utilice un conocido patrón de diseño: El [i]Decorator[/i], o Decorador.   Aplicado a la generación de vistas la solución que ofrece dicho patrón es la de   añadir funcionalidad adicional a las plantillas. Por ejemplo, añadir el menú y el   pie de página a las plantillas que lo requieran, de manera que dichos elementos   puedan reutilizarse en distintas plantillas. Literalmente se trata de [i]decorar[/i]   las plantillas con elementos adicionales reutilizables.
[/nota]

El sistema de plantillas *[i]twig[/i]*, está provisto de un mecanismo de herencia gracias al cual la decoración de plantillas resulta de una flexibilidad y versatilidad total. Podemos hacer cualquier cosa que nos imaginemos, como por ejemplo fragmentar la vista en distintas plantillas organizadas por criterios funcionales, y combinarlas para producir la vista completa. Podemos colocar en una un menú, en otra un pie de página, en otra la estructura básica del documento *[i]HTML[/i]*, otra puede pintar un listado de *twitts*, etcétera.

La herencia es un mecanismo típico de la programación orientada a objetos mediante el que un componente software hereda todas las funcionalidades de otro y puede extenderlas y/o cambiarlas. Es exactamente esto lo que ocurre cuando una plantilla [i]twig[/i] hereda de otra.

En [i]twig[/i] la herencia se implementa mediante el concepto de bloque. En las plantillas podemos delimitar [i]bloques[/i] que comienzan con un [i]{% block nombre_bloque %}[/i] y finalizan con [i]{% endblock %}[/i]. Las plantillas heredan todas las funcionalidades de las plantillas que extienden y pueden cambiar el código de los bloques heredadados. Como siempre un ejemplo vale más que mil palabras.

Fíjate en el fichero [i]app/Resources/view/base.html.twig[/i] que viene de serie en la distribución standard de [i]Symfony2[/i]:

[i]app/Resources/view/base.html.twig[/i]

  [code] <!DOCTYPE html>
   <html>
	 <head>
	    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	    <title>{% block title %}Welcome!{% endblock %}</title>
	        {% block stylesheets %}{% endblock %}
	    <link rel="shortcut icon" href="{{ asset('favicon.ico') }}" />
	 </head>
	 <body>
	    {% block body %}{% endblock %}
	    {% block javascripts %}{% endblock %}
	 </body>
   </html>[/code]

Representa la estructura básica de un documento [i]HTML[/i]. Y presenta varios bloques: [i]title[/i], [i]stylesheets[/i], [i]body[/i] y [i]javascripts[/i]. Esta plantilla es ofrecida por [i]Symfony2[/i] para que sirva de ejemplo. Pero puede utilizarse como plantilla básica de casi cualquier aplicación web. 

Vamos a modificar nuestra plantilla [i]index.html.twig[/i] para que la herede (o para que la extienda, son dos maneras de decir lo mismo):

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/Default/index.twig.html[/i]
  
[code]{% extends '::base.html.twig' %}

   {% block body %}
	
	<h1>Inicio</h1>
	<h3> Fecha: {{fecha}}  </h3>
	{{mensaje}}
	
   {% endblock %}[/code]

En la línea 1 se indica la herencia de la plantilla base. Esto significa que la plantilla [i]JazzywebAulasMentorAlimentosBundle:Default:index.twig.html[/i] asume todo el contenido de la plantilla [i]::base.html.twig[/i]. Pero además se modifica el contenido del bloque [i]body[/i] con las líneas 5-7.

Si además queremos modificar el bloque [i]title[/i], no tenemos más que añadirlo en nuestra plantilla [i]index.html.twig[/i]: 

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/Default/index.twig.html[/i]

 [code]  {% extends '::base.html.twig' %}

   {%  block title %}
     Bienvenido a la aplicación alimentos
   {% endblock %}

   {% block body %}
	
	<h1>Inicio</h1>
	<h3> Fecha: {{fecha}}  </h3>
	{{mensaje}}
	
   {% endblock %}[/code]

Ahora, en la sección [i]<title>[/i] del documento se pintará: [i]Bienvenido a la aplicación alimentos[/i] en lugar de [i]Welcome[/i].

Puedes probar a recargar la página a través de la [i]URL[/i]:

[code]  http://localhost/Symfony/web/app_dev.php/alimentos/[/code]

Aunque el aspecto de la página es el mismo que antes, si ves el código fuente [i]HTML[/i] en el navegador, comprobarás que el documento está completo, es decir, con todas sus etiquetas [i]HTML[/i]. También puedes comprobar que, al utilizar el controlador frontal de desarrollo, aparece en la parte de abajo de la página la barra de depuración de [i]Symfony2[/i]. 

[nota]Recuerda el concepto de nombre lógico de una plantilla. Y fíjate en el nombre    lógico de la plantilla [i]::base.html.twig[/i]. Como no pertenece a ningún   [i]bundle[/i] (es común a la aplicación), y está úbicada directamente en el    directorio [i]view[/i], no lleva nada ni antes del primer ":" ni del segundo.[/nota]

La herencia de plantillas puede llevarse a cabo a varios niveles, esto es, una plantilla puede heredar de otra plantilla que a su vez hereda de otra plantilla, etcétera. No obstante no se recomienda llevar a cabo muchos niveles de herencia, ya que puede llegar a ser bastante confuso e incontrolable. La estrategia que recomiendan los creadores de [i]Symfony2[/i] es usar tres niveles de herencia: 

[list]
[*] en el primer nivel se colocan la estructura básica del documento [i]HTML[/i], se  corresponde con lo que hace la plantilla [i]::base.html.twig[/i],

[*] en el segundo se colocan los elementos específicos de cada sección del sitio,  por ejemplo el menú de la sección,

[*] y en el tercero se reserva para los elementos propios de la acción, se   corresponde con nuestra plantilla    [i]JazzywebAulasMentorAlimentosBundle:Default:index.twig.html[/i]

[/list]
 
Tan sólo nos falta incluir los menús que serán comunes a todas las páginas de la aplicación. Seguiremos la estrategia de tres niveles de herencia que acabamos de exponer. Creamos la plantilla genéral [i]JazzywebAulasMentorAlimentosBundle::layout.html.twig[/i]. Según la lógica de los nombres lógicos, esta se debe ubicar en:

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/layout.twig.html[/i]

  [code] {% extends '::base.html.twig' %}

   {% block body %}
   <div id="cabecera">
     <h1>Información de alimentos</h1>
   </div>

   <div id="menu">
   <hr/>
     <a href="{{ path('JAMAB_homepage')}}">inicio</a> |
     <a href="#">ver alimentos</a> |
     <a href="#">insertar alimento</a> |
     <a href="#">buscar por nombre</a> |
     <a href="">buscar por energia</a> |
     <a href="">búsqueda combinada</a>
   <hr/>
   </div>

   <div id="contenido">
   {% block contenido %}

   {% endblock %}
   </div>

   <div id="pie">
   <hr/>
   <div align="center">- pie de página -</div>
   </div>

   {% endblock %}[/code]

[nota]
En la línea 10 hemos usado la función ``path`` de *twig* para construir   la *URL's* del menú. Está función recibe como argumento el nombre de la ruta   cuya *URL* se desea calcular. Únicamente la hemos usado en el primer enlace    del menú, pués, por ahora, es la única ruta que hemos definido.
[/nota]
   
Ahora es esta plantilla la que extiende a la plantilla base, por tanto, habrá que cambiar la plantilla
[i]JazzywebAulasMentorAlimentosBundle:Default:index.twig.html[/i] para que extienda de [i]JazzywebAulasMentorAlimentosBundle::layout.twig.html[/i], y para que redefina el bloque [i]contenido[/i] de esta última. Quedaría así:

   [code]{% extends 'JazzywebAulasMentorAlimentosBundle::layout.html.twig' %}

   {% block contenido %}
   
   <h1>Inicio</h1>
   <h3> Fecha: {{fecha}}  </h3>
   {{mensaje}}

   {% endblock %}[/code]

Vuelve a probar la página. Ya sólo nos falta incorporarle estilos [b]CSS's[/b].

[h4]Instalación de los [i]assets[/i] de un [i]bundle[/i][/h4]

Ya hemos dicho que un [i]bundle[/i] es un directorio que aloja todo aquello relativo a una funcionalidad determinada. Puede incluir clases [i]PHP[/i], plantillas, configuraciones, [i]CSS[/i]’s y [i]javascripts[/i].

Cuando los [i]bundles[/i] incluyen [i]assets[/i], es decir archivos que no son procesados por [i]PHP[/i] si no que son servidos directamente por el servidor web ([i]CSS[/i]'s, [i]javascripts[/i] e imágenes son los [i]assets[/i] más habituales), estos deben ser copiados dentro del directorio [i]web[/i] del proyecto o enlazados desde dicho directorio, ya que es ahí únicamente donde el servidor web puede acceder en busca de archivos (suponiendo que lo hemos configurado correctamente para un entorno de producción).

Por otro lado en un *bundle* los *[i]assets[/i]* deben ser ubicados en el directorio [i]Resources/public[/i]. Si lo examinas verás que tiene la siguiente estructura:

   [code] Resources
    &#9492;&#9472; public
       &#9500;&#9472;&#9472; css
       &#9500;&#9472;&#9472; images
       &#9492;&#9472;&#9472; js[/code]

Se ha reservado un directorio para cada tipo de [i]asset[/i]. Copia el siguiente código [i]CSS[/i]'s en el archivo [i]Resources/public/css[/i] del [i]bundle[/i].
   
   [css] body {
      padding-left: 11em;
      font-family: Georgia, "Times New Roman",
            Times, serif;
      color: purple;
      background-color: #d8da3d }
    ul.navbar {
      list-style-type: none;
      padding: 0;
      margin: 0;
      position: absolute;
      top: 2em;
      left: 1em;
      width: 9em }
    h1 {
      font-family: Helvetica, Geneva, Arial,
            SunSans-Regular, sans-serif }
    ul.navbar li {
      background: white;
      margin: 0.5em 0;
      padding: 0.3em;
      border-right: 1em solid black }
    ul.navbar a {
      text-decoration: none }
    a:link {
      color: blue }
    a:visited {
      color: purple }
    address {
      margin-top: 1em;
      padding-top: 1em;
      border-top: thin dotted }
    #contenido {
      display: block;
      margin: auto;
      width: auto;
      min-height:400px;
    }
[/css]

Para que el servidor web la pueda cargar, se utiliza el siguiente comando de consola:
  
 [code]php app/console assets:install web --symlink[/code]

La función de este comando es realizar una copia o un enlace simbólico (si se especifica la opión [i]--symlink[/i], aunque en la plataforma [i]Windows[/i] esto último no es posible) del contenido de los directorios [i]Resouces/public[/i] de todos los [i]bundles[/i] que se encuentren registrados en el framework. El comando requiere un argumento ([i]web[/i] en nuestro caso), que especifica el directorio donde se realizará la copia o el enlace simbólico. 

Dicha copia o enlazado se organiza de la siguiente manera:

    [code]web
    &#9500;&#9472; nombre_bundle_1
    |  &#9500;&#9472;&#9472; css
    |  &#9500;&#9472;&#9472; images
    |  &#9492;&#9472;&#9472; js
    &#9500;&#9472; nombre_bundle_2
    |  &#9500;&#9472;&#9472; css
    |  &#9500;&#9472;&#9472; images
    |  &#9492;&#9472;&#9472; js
    ...
    &#9492;&#9472; nombre_bundle_N
       &#9500;&#9472;&#9472; css
       &#9500;&#9472;&#9472; images
       &#9492;&#9472;&#9472; js[/code]

Ya sólo falta incluir una referencia en el código [i]HTML[/i] a la [i]CSS[/i] que acabamos de incorporar. Aunque es posible incluir el enlace a la [i]CSS[/i] directamente en la plantilla [i]::base.html.twig[/i], el lugar correcto es en la plantilla [i]JazzywebAulasMentosAlimentosBundle::layout.html.twig[/i]. Teniendo en cuenta lo que hemos explicado acerca del mecanismo de herencia, habría que añadir un bloque [i]stylesheets[/i] (heredado de la plantilla padre [i]::base.html.twig[/i]), en el que se haga referencia al archivo [i]CSS[/i].

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/layout.html.twig[/i]
  
[code]...
   {% block stylesheets %}
    <link href="{{ asset('bundles/jazzywebaulasmentoralimentos/css/estilo.css') }}" type="text/css" rel="stylesheet" />
   {% endblock %} 
   ...[/code]
 
En este código hemos utilizado la función de [i]twig[/i] [i]asset[/i], la cual crea la [i]URL[/i] correcta que apunta al asset en cuestion. La ruta que toma como argumento  la función asset se especifica tomando como raíz el directorio [i]web[/i].

[nota] Puedes colocar el bloque [i]stylesheets[/i] delante o detrás del bloque [i]body[/i].[/nota]

Recarga la página y la verás con los estilos aplicados.

[h4]Implementamos el resto de la aplicación[/h4]

Siguiendo estos tres pasos: enrutar, crear código de la acción (controlador) y crear la plantilla, podemos completar lo que nos falta de la aplicación. No obstante, en las acciones que faltan, se necesita acceder a la base de datos para recuperar, modificar y crear alimentos. La distribución standard de [i]Symfony2[/i]  proporciona un potente servicio para el acceso a los datos persistentes, es decir, los que se almacenan en algún tipo de base de datos. Pero no obliga a utilizarlo. No solo eso, tampoco forma parte del núcleo de [i]Symfony2[/i], es decir, no es un componente. Por ello es una decisión del desarrollador utilizarlo o no. Es en ese sentido que [i]Fabien Potencier[/i], lider del proyecto [i]Symfony2[/i], proclama que este último no es un framework [i]MVC[/i], ya que no dice nada sobre como debes construir tu modelo.

Aunque lo recomendable es utilizar [i]Doctrine2[/i] (que es el servicio de persistencia que viene incorporado en la distribución standard), o [i]Propel[/i], en este tutorial no los vamos a utilizar por que ya llevamos muchos conceptos introducidos y no queremos sobrecargarlo. Además queremos ilustrar como podemos construir el modelo a nuestro antojo.

Así pues, antes de implentar el resto de las acciones que componen la aplicación, vamos a elaborar el modelo.

Crea un directorio denominado [i]Model[/i] (el nombre puede ser cualquiera), y crea ahí un fichero [i]Model.php[/i] con el siguiente código: 

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Model/Model.php[/i]

   [php] <?php

    namespace Jazzyweb\AulasMentor\AlimentosBundle\Model;

    class Model
    {
	protected $conexion;

	 public function __construct($dbname,$dbuser,$dbpass,$dbhost)
     {   
         $mvc_bd_conexion = mysql_connect($dbhost, $dbuser, $dbpass);

         if (!$mvc_bd_conexion) {
             die('No ha sido posible realizar la conexión con la base de datos: '
             . mysql_error());
         }
         mysql_select_db($dbname, $mvc_bd_conexion);

         mysql_set_charset('utf8');

         $this->conexion = $mvc_bd_conexion;
     }


	public function bd_conexion()
	{
	    
	}

	public function dameAlimentos()
	{
	    $sql = "select * from alimentos order by energia desc";

	    $result = mysql_query($sql, $this->conexion);

	    $alimentos = array();
	    while ($row = mysql_fetch_assoc($result))
	    {
		$alimentos[] = $row;
	    }

	    return $alimentos;
	}

	public function buscarAlimentosPorNombre($nombre)
	{
	    $nombre = htmlspecialchars($nombre);

	    $sql = "select * from alimentos where nombre like '" . $nombre . "' order
	     by energia desc";

	    $result = mysql_query($sql, $this->conexion);

	    $alimentos = array();
	    while ($row = mysql_fetch_assoc($result))
	    {
		$alimentos[] = $row;
	    }

	    return $alimentos;
	}
	
	public function dameAlimento($id)
	{
	    $id = htmlspecialchars($id);
	    
	    $sql = "select * from alimentos where id=".$id;
	    
	    $result = mysql_query($sql, $this->conexion);

	    $alimentos = array();
	    $row = mysql_fetch_assoc($result);
	    
	    return $row;
	    
	}

        public function insertarAlimento($n, $e, $p, $hc, $f, $g)
	{
	    $n = htmlspecialchars($n);
	    $e = htmlspecialchars($e);
	    $p = htmlspecialchars($p);
	    $hc = htmlspecialchars($hc);
	    $f = htmlspecialchars($f);
	    $g = htmlspecialchars($g);

	    $sql = "insert into alimentos (nombre, energia, proteina, hidratocarbono, 
	    fibra, grasatotal) values ('" .
		    $n . "'," . $e . "," . $p . "," . $hc . "," . $f . "," . $g . ")";

	    $result = mysql_query($sql, $this->conexion);

	    return $result;
	}

    }[/php]

El próximo paso es completar el código del controlador con el resto de las acciones que se han mapeado en las rutas definidas anteriormente. El código del controlador [i]DefaultController[/i] quedaría así:

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Controller/DefaultController.php[/i]
  
 [php] <?php

    namespace Jazzyweb\AulasMentor\AlimentosBundle\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\Controller;
    use Jazzyweb\AulasMentor\AlimentosBundle\Model\Model;
    use Jazzyweb\AulasMentor\AlimentosBundle\Config\Config;

    class DefaultController extends Controller
    {

        public function indexAction()
        {
            $params = array(
            'mensaje' => 'Bienvenido al curso de Symfony2',
            'fecha' => date('d-m-yyy'),
            );
    
            return
             $this->render('JazzywebAulasMentorAlimentosBundle:Default:index.html.twig',
             $params);
        }
    
        public function listarAction()
        {
            $m = new Model(Config::$mvc_bd_nombre, Config::$mvc_bd_usuario,
                            Config::$mvc_bd_clave, Config::$mvc_bd_hostname);
    
            $params = array(
            'alimentos' => $m->dameAlimentos(),
            );
    
            return
             $this->render('JazzywebAulasMentorAlimentosBundle:Default:mostrarAlimentos.html.twig', 
             $params);
        
        }
    
        public function insertarAction()
        {
            $params = array(
            'nombre' => '',
            'energia' => '',
            'proteina' => '',
            'hc' => '',
            'fibra' => '',
            'grasa' => '',
            );
    
            $m = new Model(Config::$mvc_bd_nombre, Config::$mvc_bd_usuario,
             Config::$mvc_bd_clave, Config::$mvc_bd_hostname);
    
            if ($_SERVER['REQUEST_METHOD'] == 'POST') {
    
            // comprobar campos formulario
            if ($m->insertarAlimento($_POST['nombre'], $_POST['energia'], 
             $_POST['proteina'], $_POST['hc'], $_POST['fibra'], $_POST['grasa'])) {
                $params['mensaje'] = 'Alimento insertado correctamente';
            } else {
                $params = array(
                'nombre' => $_POST['nombre'],
                'energia' => $_POST['energia'],
                'proteina' => $_POST['proteina'],
                'hc' => $_POST['hc'],
                'fibra' => $_POST['fibra'],
                'grasa' => $_POST['grasa'],
                );
                $params['mensaje'] = 'No se ha podido insertar el alimento. Revisa el formulario';
            }
            }
    
            return
             $this->render('JazzywebAulasMentorAlimentosBundle:Default:formInsertar.html.twig', 
             $params);
        
        }
    
        public function buscarPorNombreAction()
        {
            $params = array(
            'nombre' => '',
            'resultado' => array(),
            );
    
            $m = new Model(Config::$mvc_bd_nombre, Config::$mvc_bd_usuario,
                            Config::$mvc_bd_clave, Config::$mvc_bd_hostname);
    
            if ($_SERVER['REQUEST_METHOD'] == 'POST') {
            $params['nombre'] = $_POST['nombre'];
            $params['resultado'] = $m->buscarAlimentosPorNombre($_POST['nombre']);
            }
    
            return 
             $this->render('JazzywebAulasMentorAlimentosBundle:Default:buscarPorNombre.html.twig',
             $params);
        
        }
    
        public function verAction()
        {
            if (!isset($_GET['id'])) {
            throw new Exception('Página no encontrada');
            }
    
            $id = $_GET['id'];
    
            $m = new Model(Config::$mvc_bd_nombre, Config::$mvc_bd_usuario,
                            Config::$mvc_bd_clave, Config::$mvc_bd_hostname);
    
            $alimento = $m->dameAlimento($id);
    
            $params = $alimento;
    
            return 
             $this->render('JazzywebAulasMentorAlimentosBundle:Default:verAlimento.html.twig',
            $params);
        
        }

    }[/php]

Para que podamos utilizar la clase [i]Model[/i] en el controlador sin necesidad de referirnos a ella por su nombre completo, [i]Jazzyweb\AulasMentor\AlimentosBundle\Model\Model[/i], hemos utilizado (línea 6) la directiva [i]use[/i] de [i]PHP 5.3[/i] en dicho fichero. Así podemos utilizar la clase [i]Model[/i] directamente en el controlador.

En la clase [i]Model[/i] puedes observar que,  para el acceso a la base de datos, se hace referencia a unos parámetros de configuración a través de la clase estática [i]Config[/i]. Crea dicha clase en el fichero [i]src/Jazzyweb/AulasMentor/AlimentosBundle/Config/Config.php[/i], con el siguiente código:

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Config/Config.php[/i]

    [php]<?php

    namespace Jazzyweb\AulasMentor\AlimentosBundle\Config;
    
    class Config
    {
        static public $mvc_bd_hostname = "localhost";
        static public $mvc_bd_nombre   = "alimentos";
        static public $mvc_bd_usuario  = "root";
        static public $mvc_bd_clave    = "root";
        static public $mvc_vis_css     = "estilo.css";
    }[/php]
    
Esta forma de especificar los parámetros de configuración no es la más "[i]symfónica[/i]", pero es suficiente para los propósitos de este tutorial. En otro tutorial explicaremos como usar la inyección de dependencias para declarar los parámetros en el [i]Symfony2 way[/i].

Como puedes ver hemos comenzado por el 2º paso del flujo básico de desarrollo de páginas con *[i]Symfony2[/i]* es decir, escribir el controlador. En realidad el orden no importa mucho; al final hay que tener los tres pasos resueltos antes de que funcione. Así que vamos a por el primer paso: definir las rutas. Esto lo hacemos editando el fichero  [i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/config/routing.yml[/i] y plasmando ahí la tabla de rutas. Recuerda:

[code]
/          (mostrar pantalla inicio)
/listar    (listar alimentos)
/insertar  (insertar un alimento)
/buscar    (buscar alimentos)
/ver/x     (ver el alimento x)
[/code]

El archivo [i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/config/routing.yml[/i] queda así:

   [code] JAMAB_homepage:
      pattern:  /
      defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:index }

    JAMAB_listar:
      pattern:  /listar
      defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:listar }

    JAMAB_insertar:
      pattern:  /insertar
      defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:insertar }
      
    JAMAB_buscar:
      pattern:  /buscar
      defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:buscarPorNombre }

    JAMAB_ver:
      pattern:  /ver/{id}
      defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:ver }
[/code]

La última ruta ([i]JAMAB_ver[/i]) utiliza una funcionalidad muy interesante del sistema de [i]Routing[/i] de [i]Symfony2[/i] que se utiliza continuamente. Se trata de introducir en la propia ruta los parámetros que se pasarán por [i]GET[/i] al servidor web. Los valores encerrados entre llaves, en nuestro caso [i]{id}[/i], se denominan [i]placeholders[/i]. El sistema de [i]Routing[/i] parsea las [i]URL[/i]'s que coincidan con la ruta y asigna el valor que venga en la posición de cada [i]placeholder[/i] a una variable denominada con el nombre especificado entre las llaves. Veámoslo con un ejemplo. La siguiente ruta:

  [code] http://localhost/Symfony/web/app_dev.php/alimentos/ver/5
[/code]

Coincide con la ruta [i]JAMAB_ver[/i] (recuerda que a todas las rutas del [i]bundle[/i] les hemos colocado el prefijo [i]alimentos[/i]). El sistema de [i]Routing[/i], al parsearla, asignará al objeto [i]Request[/i] de [i]Symfony2[/i] una variable denominada [i]id[/i], con un valor [i]5[/i]. Además, esta variable se pasará como argumento al controlador especificado en la ruta, en nuestro caso a [i]JazzywebAulasMentorAlimentosBundle:Default:ver[/i]. Se consigue, además de  usar [i]URL[/i]'s elegantes en la que sólo se utiliza el caracter  "/", eliminar el nombre de las variables de la [i]query string[/i], ocultando información que no es necesaria para el cliente.

[i]Symfony2[/i] mapea esta ruta en una acción llamada [i]verAction($id)[/i] a la que se le pasa el argumento [i]id[/i]. Vamos a cambiar la acción [i]verAction()[/i] para que su código sea más correcto y [i]symfónico[/i]:

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Controller/DefaultController.php[/i]

  [php] <?php
   ...
   public function verAction($id)
   {                
	   $m = new Model(Config::$mvc_bd_nombre, Config::$mvc_bd_usuario,
                        Config::$mvc_bd_clave, Config::$mvc_bd_hostname);

	   $alimento = $m->dameAlimento($id);
	    
	   if(!$alimento)
	   {
	     throw new \Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException();
	   }

	   $params = $alimento;

	   return $this->render('JazzywebAulasMentorAlimentosBundle:Default:verAlimento.html.twig', $params);
	
    }   
    ...[/php]

En la línea 3 hemos introducido un argumento para recoger la variable creada por el sistema de [i]Routing[/i], y en las líneas 9-12 hemos utilizado las excepciones de [i]Symfony2[/i] para tratar el caso de que el registro no exista. Fíjate que de esta manera no necesitamos utilizar la variable superglobal [i]$_GET[/i] de [i]PHP[/i]. 

[nota] En lugar del nombre completo [i]\Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException()[/i],   puedes utilizar [i]AccessDeniedHttpException()[/i], si referencias el espacio   de nombre al principio del fichero mediante la directiva [i]use[/i]. [/nota]

[nota]Las acciones [i]buscarPorNombreAction[/i] y [i]insertarAction[/i], hacen uso de   la variable global de [i]PHP[/i] [i]$_POST[/i]. Esto es una mala práctica en    [i]Symfony2[/i], ya que en su lugar se debe utilizar el objeto [i]Request[/i] del   framework, que es una abstracción de la petición ([i]request[/i]) [i]HTTP[/i] en la que   se han "limpiado" los valores de sus atributos de posibles cadenas potencialmente   peligrosas (código malicioso). Será la primera y ultima vez que haremos esto.    Sirva como ejemplo de que  el hecho de utilizar un framework ayuda pero no es    suficiente para generar un código de calidad. Es el programador quien, conociendo   y aplicando las buenas prácticas de programación, produce un buen código. [/nota]

Y ahora a por las plantillas. 

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/Default/verAlimento.html.twig[/i]

[code]     {% extends 'JazzywebAulasMentorAlimentosBundle::layout.html.twig' %}

     {% block contenido %}
    
     <h1>{{ nombre }}</h1>
     <table border="1">
    
         <tr>
             <td>Energía</td>
             <td>{{ energia }} </td>
         </tr>
         <tr>
             <td>Proteina</td>
             <td>{{ proteina }}</td>
         </tr>
         <tr>
             <td>Hidratos de Carbono</td>
             <td>{{ hidratocarbono }}</td>
         </tr>
         <tr>
             <td>Fibra</td>
             <td>{{ fibra }}</td>
         </tr>
         <tr>
             <td>Grasa total</td>
             <td> {{grasatotal}} </td>
         </tr>
     </table>
    
    {% endblock %}[/code]


[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/Default/mostrarAlimentos.html.twig[/i]

    [code]{% extends 'JazzywebAulasMentorAlimentosBundle::layout.html.twig' %}
    
     {% block contenido %}
    
     <table>
         <tr>
             <th>alimento (por 100g)</th>
             <th>energía (Kcal)</th>
             <th>grasa (g)</th>
         </tr>
         {% for alimento in alimentos %}
         <tr>
             <td><a href="{{ path('JAMAB_ver', {'id': alimento.id}) }}">{{alimento.nombre}}</a></td>
             <td>{{ alimento.energia }}</td>
             <td>{{ alimento.grasatotal }}</td>
         </tr>
         {% endfor %}
    
     </table>
    
     {% endblock %}  [/code]  


En esta última plantilla hemos introducido tres elementos nuevos del sistema [i]twig[/i]:
[list]
[*] La navegación por un array. Fíjate que la acción  que utiliza esta plantilla,  [i]listarAction()[/i], le pasa como parámetros una colección (array) de alimentos  devueltos por el método [i]dameAlimentos[/i] del modelo. Las colecciones, es   decir los arrays indexados (no asociativos), pueden ser iterados en una   plantilla [i]twig[/i] mediante la construcción [i]{% for dato in datos %}[/i] -  [i]{% endfor %}[/i],  donde [i]datos[/i] es el array que llega a la plantilla.

[*] Por otro lado, cada elemento del array [i]alimentos[/i] es un array asociativo.  Sus elementos pueden ser accedido mediante la notación [i]dato.propiedad[/i].   Una característica interesante de esta notación es que se puede utilizar no  solo con arrays asociativos, sino con objetos provistos de [i]getters[/i] sobre sus  propiedades. Este hecho se utiliza intensa y extensamente en [i]Symfony2[/i].
  
[*] Por último se utiliza la función [i]path()[/i] de [i]twig[/i], que sirve para calcular  la [i]URL[/i] correcta a partir del nombre de la ruta. Así cuando cambiemos la   aplicación de servidor o de ubicación, la ruta será calculada correctamente.   Los argumentos de la ruta se pasan a la función [i]path[/i] usando la sintaxis   de un objeto [i]JSON[/i], es decir: [i]{ 'param1': val1, ..., `paramN': valN }[/i].Esta función será otro de los elementos omnipresentes en cualquier aplicación  web construida con [i]Symfony2[/i] y [i]twig[/i].
[/list]

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/Default/formInsertar.html.twig[/i]
  
  [code]  {% extends 'JazzywebAulasMentorAlimentosBundle::layout.html.twig' %}
    
     {% block contenido %}
    
    {% if mensaje is defined %}
    <b><span style="color: red;">{{ mensaje }}</span></b>
    {% endif %}
    <br/>
    <form name="formInsertar" action="{{ path('JAMAB_insertar') }}" method="POST">
        <table>
            <tr>
                <th>Nombre</th>
                <th>Energía (Kcal)</th>
                <th>Proteina (g)</th>
                <th>H. de carbono (g)</th>
                <th>Fibra (g)</th>
                <th>Grasa total (g)</th>
            </tr>
            <tr>
                <td><input type="text" name="nombre" value="{{ nombre }}" /></td>
                <td><input type="text" name="energia" value="{{ energia }}" /></td>
                <td><input type="text" name="proteina" value="{{ proteina }}" /></td>
                <td><input type="text" name="hc" value="{{ hc }}" /></td>
                <td><input type="text" name="fibra" value="{{ fibra }}" /></td>
                <td><input type="text" name="grasa" value="{{ grasa }}" /></td>
            </tr>
    
        </table>
        <input type="submit" value="insertar" name="insertar" />
    </form>
    * Los valores deben referirse a 100 g del alimento
    
    {% endblock %}[/code]
  
En esta plantilla hemos introducido otro elemento nuevo; la construcción [i]{% if data is defined %}[/i] - [i]{% endif %}[/i], que como puedes deducir, comprueba si la variable [i]data[/i] ha sido definida. 

También hemos vuelto a utilizar la función [i]path[/i]  para escribir el parámetro [i]action[/i] del formulario [i]HTML[/i].

Llegados a este punto hemos de aclarar que [i]Symfony2[/i] proporciona un potente servicio para la construcción de formularios que no estudiaremos en este tutorial. Por lo pronto nos quedamos con esta manera sencilla y directa de crear formularios.
  
Vamos a por la siguiente plantilla:

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/Default/buscarPorNombre.html.twig[/i]
   
   [code] {% extends 'JazzywebAulasMentorAlimentosBundle::layout.html.twig' %}
    
     {% block contenido %}
    
    <form name="formBusqueda" action="{{ path('JAMAB_buscar') }}" method="POST">
    
         <table>
             <tr>
                 <td>nombre alimento:</td>
                 <td><input type="text" name="nombre" value="{{ nombre }}">(puedes utilizar '%' como comodín)</td>
    
                 <td><input type="submit" value="buscar"></td>
             </tr>
         </table>
    
         </table>
    
     </form>
    
     {% if resultado %}
     {% include 'JazzywebAulasMentorAlimentosBundle:Default:_tablaAlimentos.html.twig' with {'alimentos': resultado} %}
     {% endif %}
    
    {% endblock %}[/code]

Otro elemento nuevo; la inclusión de plantillas en otras plantillas. Esto lo hacemos en la línea 21 mediante la función [i]include[/i] de [i]twig[/i], la cual requiere como argumento el nombre lógico de la plantilla que se desea incluir. Los parámetros que necesita la plantilla incluida se pasan en un array con sintaxis [i]JSON[/i] despues del token [i]with[/i].

Este mecanismo de inclusión combinado con la herencia proporciona una gran flexibilidad al programador, otorgándole las herramientas necesarias para elaborar un código bien organizado y reusable.

La plantilla incluida es la siguiente:

 [i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/Default/_tablaAlimentos.html.twig[/i]
  
    [code]<table>
         <tr>
             <th>alimento (por 100g)</th>
             <th>energía (Kcal)</th>
             <th>grasa (g)</th>
         </tr>
         {% for alimento in alimentos %}
         <tr>
             <td>{{ alimento.nombre }}</td>
             <td>{{ alimento.energia }}</td>
             <td>{{ alimento.grasatotal }}</td>
         </tr>
         {% endfor %}
    
     </table>[/code]

Y, por último, utilizando esta última plantilla que pinta un listado de alimentos, podemos simplificar la plantilla [i]mostrarAlimentos.html.twig[/i] evitando la repetición de código innecesariamente.

[i]src/Jazzyweb/AulasMentor/AlimentosBundle/Resources/view/Default/mostrarAlimentos.html.twig[/i]

   [code] {% extends 'JazzywebAulasMentorAlimentosBundle::layout.html.twig' %}
    
    {% block contenido %}
    
    {% include 'JazzywebAulasMentorAlimentosBundle:Default:_tablaAlimentos.html.twig' with {'alimentos': alimentos} %}
    
    {% endblock %}   [/code]
    
Y con esto ya tenemos la aplicación de gestión de alimentos terminada y construida en [i]Symfony2[/i]. Aún puede hacerse de un modo más symfónico, utilizando los servicios de persistencia de datos ([i]Doctrine[/i]), de creación de formularios y de validación de datos. Pero la intención de este tutorial es mostrar los elementos básicos para la creación de páginas en [i]Symfony2[/i], y por tanto vamos a dar por buena la aplicación tal y como está.

Únicamente faltaría usar la función [i]path()[/i] de [i]twig[/i] para completar los enlaces de los menús. Pero eso vamos a dejar que lo hagas tú.


[h3]El tutorial en chuletas[/h3]


[h4]Generar un [i]bundle[/i][/h4]

   [code]php app/console generate:bundle[/code]

[h4]Registrar un [i]bundle[/i][/h4]

Se hace en el archivo [i]app/KernelApp.php[/i], de la siguiente manera:

  [code] ...
   new Jazzyweb\AulasMentor\AlimentosBundle\JazzywebAulasMentorAlimentosBundle(),
   ...[/code]
   
[h4]Enlazar el [i]routing[/i] de un [i]bundle[/i] con el [i]routing[/i] general de la aplicación[/h4]

Se hace añadiendo al archivo [i]app/config/routing.yml[/i] (o [i]routing_{env}.yml[/i]):

 [code]  JazzywebAulasMentorAlimentosBundle:
   resource: "@JazzywebAulasMentorAlimentosBundle/Resources/config/routing.yml"
   prefix:   /[/code]

[h4]Pasos para acoplar un [i]bundle[/i] al framework[/h4]

1. Registrar el espacio de nombre en el sistema de autocarga. Este paso no es    necesario si ubicamos al [i]bundle[/i] en el directorio [i]src[/i].

2. Registrar al bundle en el fichero [i]app/AppKernel.php[/i]. Esta operación se   puede hacer automáticamente a través del generador interactivo de [i]bundles[/i],   pero si fallase por alguna razón (por ejemplo que los permisos de dicho archivo   no estén bien definidos). Habría que hacerlo a mano.

3. Importar las tablas de enrutamiento del [i]bundle[/i] en la tabla de enrutamiento   de la aplicación.
   
[h4]Flujo para la creación de páginas en [i]Symfony2[/i][/h4]

1. Creación de la ruta en [i]config/Resources/routing.yml[/i] del [i]bundle[/i], o   directamente en [i]app/config/routing.yml[/i].

2. Creación de la acción en el controlador correspondiente en una clase que debe   ubicarse en un fichero del directorio [i]Controllers[/i] del [i]bundle[/i].
   
3. Creación de una plantilla en el directorio [i]Resources/view[/i].

[h4]Nombres lógicos de acciones[/h4]

[i]NombreBundle:NombreControlador:NombreAcción[/i].

Ejemplo:

[i]AcmeDemoBundle:Secured:login[/i] se mapea en la acción [i]loginAction()[/i] de la
clase [i]Acme\DemoBundle\Controller\SecuredController[/i] definida (normalmente) en
[i]src/Acme/DemoBundle/Controller/SecuredController.php[/i].

[h4]Sintaxis básica de [i]twig[/i][/h4]

[i]{{ parametro }}[/i] -> pinta el valor de la variable [i]parametro[/i].

[i]{% comando %} ... {% endcomando %}[/i] -> ejecuta la acción expresada por 
[i]comando[/i] en el bloque definido desde su declaración hasta [i]{% endcomando%}[/i].

[h4]Herencia en plantilla [i]twig[/i][/h4]

Esta plantilla hereda de [i]JazzywebAulasMentorAlimentosBundle::layout.html.twig[/i], y modifica el bloque [i]contenido[/i] que allí se declara.

  [code] {% extends 'JazzywebAulasMentorAlimentosBundle::layout.html.twig' %}

   {% block contenido %}
   
   <h1>Inicio</h1>
   <h3> Fecha: {{fecha}}  </h3>
   {{mensaje}}

   {% endblock %}[/code]
   
[h4]Función [i]path[/i] de [i]twig[/i][/h4

 [code]  {{ path('JAMAB_listar', {'id': alimento.id}) }}[/code]
   
[h4]Iterar una colección (array) de datoso en [i]twig[/i][/h4]
   
  [code] {% for alimento in alimentos %}
     <tr>
         <td><a href="{{ path('JAMAB_listar', {'id': alimento.id}) }}">{{alimento.nombre}}</a></td>
         <td>{{ alimento.energia }}</td>
         <td>{{ alimento.grasatotal }}</td>
     </tr>
   {% endfor %}
   
[h4]Código condicional en [i]twig[/i][/h4]
    
  [code] {% if data is defined %} 
    ...
   {% endif %}[/code][/code]
   
[h4]Inclusión de plantillas en [i]twig[/i][/h4]

   [code]{% include 'JazzywebAulasMentorAlimentosBundle:Default:_tablaAlimentos.html.twig' with {'resultado': resultado} %}[/code]
 
[h4]Estructura básica de una ruta[/h4]

   [code] nombre_unico_de_la_ruta:
      pattern:  /el/patron/de/la/ruta/{param1}/{param2}/.../{paramN}
      defaults: { _controller: NombreLogico:del:Controlador }[/code]
      
    Ejemplo:
    
   [code] JAMAB_ver:
      pattern:  /ver/{id}
      defaults: { _controller: JazzywebAulasMentorAlimentosBundle:Default:ver }[/code]
  
  ____________________________________________________________________________________

Este trabajo, por Juan David Rodríguez García<juanda at ite.educacion.es>, se encuentra bajo una  Licencia [url=http://creativecommons.org/licenses/by-nc-sa/3.0/]Creative Commons Reconocimiento-NoComercial-CompartirIgual 3.0 Unported[/url].

[img]http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png[/img]

[nota]El original de este tutorial puedes encontrarlo en: [url=http://juandarodriguez.es/tutoriales-2/tutorial-de-symfony2/]http://juandarodriguez.es/tutoriales-2/tutorial-de-symfony2[/url]/[/nota]

